SET
    search_path = web,
    public;

CREATE TABLE IF NOT EXISTS project (
    id int GENERATED BY DEFAULT AS IDENTITY --ALWAYS еще можно 
    PRIMARY KEY,
    name TEXT CONSTRAINT name_length CHECK (char_length(name) <= 255) UNIQUE NOT NULL
);

CREATE TABLE IF NOT EXISTS job (
    job_type text PRIMARY KEY,
    charge_per_hour int CONSTRAINT positive CHECK (charge_per_hour > 0) NOT NULL
);

CREATE TABLE IF NOT EXISTS employee (
    id int PRIMARY KEY,
    name text CONSTRAINT employee_name_length CHECK (char_length(name) <= 255) NOT NULL,
    job_type text REFERENCES job(job_type) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE IF NOT EXISTS assignment (
    project_id int REFERENCES project(id) NOT NULL,
    employee_id int REFERENCES employee(id) NOT NULL,
    hours int,
    PRIMARY KEY (project_id, employee_id)
);

DROP TABLE IF EXISTS assignment;

DROP TABLE IF EXISTS employee;

DROP TABLE IF EXISTS project CASCADE;

DROP TABLE IF EXISTS job;

insert into
    job(job_type, charge_per_hour)
values
    ('Software Engineer', 6),
    ('Junior Software Engineer', 5);

--DELETE FROM project WHERE id=14 (удалить какие то конкретные картежы из таблички)
--RETURNING * 
--;
ALTER table
    project
add
    constraint uniq_name UNIQUE(name) --TRUNCATE project: быстрее чем delete, т.к. trauncate
    --удаляет таблицу полностью и пересоздает ее, а delete честно проходится
    --по всем записям
INSERT INTO
    project(id, name)
VALUES
    (15, 'Meta Cortex'),
    (12, 'ENCOM') ON CONFLICT (name) DO
UPDATE
SET
    name = EXCLUDED.name || '_1' --Restict, nothing
;

SELECT
    id,
    name
FROM
    PROJECT;

SELECT
    p.id,
    p.name
FROM
    PROJECT AS p
WHERE
    p.name LIKE 'ENCOM%';

SELECT
    p.id,
    p.name
FROM
    PROJECT AS p
WHERE
    p.name ILIKE 'encom%';

--регистронезависим
SELECT
    id,
    name
FROM
    (
        SELECT
            p.id,
            p.name
        FROM
            PROJECT AS p
        WHERE
            p.name ILIKE 'encom%'
    )
ORDER BY
    id ASC;

--временная таблица, существуют только в текущей сессии
CREATE TEMP TABLE IF NOT EXISTS employee_grade (
    id int,
    name TEXT,
    department TEXT,
    grade TEXT
);

INSERT INTO
    employee_grade (id, name, department, grade)
VALUES
    (1, 'John', 'HR', 'A'),
    (2, 'Mark', 'HR', 'A'),
    (3, 'Smit', 'IT', 'A'),
    (4, 'Lili', 'IT', 'B'),
    (5, 'Alex', 'PR', 'B'),
    (6, 'Walton', 'HR', 'B'),
    (7, 'Kim', 'PR', 'B'),
    (8, 'Marry', 'HR', 'A'),
    (9, 'Paul', 'PR', 'C'),
    (10, 'Christ', 'HR', 'A');

SELECT
    *
FROM
    employee_grade;

CREATE TEMP VIEW employee_int_grade AS (
    SELECT
        name,
        CASE
            WHEN grade = 'A' THEN 5
            WHEN grade = 'B' THEN 4
            WHEN grade = 'C' THEN 3
            WHEN grade = 'D' THEN 2
            ELSE NULL
        END AS grade,
        department
    FROM
        employee_grade
);

SELECT
    *
FROM
    employee_int_grade;

SELECT
    AVG(grade),
    COUNT(*),
    department
FROM
    employee_int_grade
GROUP BY
    department
ORDER BY
    department;

SELECT
    name,
    department,
    grade,
    AVG(grade) OVER (PARTITION BY department) AS avg_grade,
    grade - AVG(grade) OVER (
        PARTITION BY department
        ORDER BY
            grade
    ) AS ordered_diff,
    grade - AVG(grade) OVER (PARTITION BY department) AS diff -- оконная функция 
FROM
    employee_int_grade
ORDER BY
    department,
    grade;

CREATE TABLE tmployee (
    employeeID INT PRIMARY KEY,
    lastName text,
    country text
);

SELECT
    F.employeeID,
    F.lastName,
    S.employeeID,
    S.lastName,
    F.country
FROM
    tmployee F
    INNER JOIN tmployee S ON F.country = S.country
WHERE
    F.employeeID < S.employeeID --чтобы самого с собой не мерджить
ORDER BY
    F.lastName,
    S.lastName;

INSERT INTO
    tmployee (EmployeeID, LastName, Country)
VALUES
    (1, 'Иванов', 'Россия'),
    (2, 'Петров', 'Россия'),
    (3, 'Сидоров', 'Казахстан'),
    (4, 'Смит', 'США'),
    (5, 'Джонсон', 'США');

SELECT
    F.employeeID,
    F.LastName,
    S.employeeID,
    S.lastName,
    F.country
FROM
    tmployee F
    INNER JOIN tmployee S ON F.country = S.country
WHERE
    F.employeeID < S.employeeID
ORDER BY
    F.employeeID,
    S.employeeID;

SELECT
    *
FROM
    UNNEST (ARRAY [
1, 2, 3], ARRAY [ 'foo', 'bar', 'baz']) n (a, b)
ORDER BY
    a;

--РК №1
--------------------------------------------------------------------------------------------------------------
--Вопрос 3 
--Дана схема с одним отношением, состоящим из следующих атрибутов. Какой нормальной форме соответствует данная схема? 
--Приведите его к 3ей нормальной форме. Процесс приведения описывать не нужно. 
--Нужен только результат с описанием того, каким требованиям отвечает полученная схема.
--{ Название субъекта РФ, 
--Количество жителей субъекта РФ, 
--Название города, 
--Количество жителей города, 
--ФИО гражданина (который живет в городе), 
--Дата рождения,
--Серия и номер паспорта }
--Условие первой нормальной формы: каждый картеж содержит только одно значение для атрибута
--Кажется можно разбить ФИО гражданина, но если не обращать внимание на это, то условие первой НФ выполнено.
--Условие второй НФ: не должно быть зависимости от части ключа
--Выполнено.
--Условие 3 НФ: любой столбец таблицы должен зависеть только от ключевого столбца.
--Разобъем данное отношение на три:
--1) { Серия и номер паспорта, ФИО гражданина (который живет в городе), Дата рождения, Название города }.
--2) { Название города, Количество жителей города, Название субъекта РФ }.
--3) { Название субъекта РФ, Количество жителей субъекта РФ }.
--------------------------------------------------------------------------------------------------------------
--Оптимально ли составлен запрос? Какие индексы нужно построить для эффективного выполнения запроса и почему?
--SELECT film.title, SUM(payment.amount)
--FROM customer
--JOIN rental ON (rental.customer_id = customer.customer_id)
--JOIN inventory ON (rental.inventory_id = inventory.inventory_id)
--JOIN film ON (inventory.film_id = film.film_id)
--JOIN payment ON (payment.rental_id = rental.rental_id)
--WHERE EXTRACT(YEAR FROM rental.rental_date) = 2005
--  AND customer.store_id = 2
--GROUP BY film.title;
-- Для отношения customer можно создать индекс store_id, чтобы ускорить where ... and customer.store_id = 2
-- Для отношения rental также можно создать индекс rental_date, чтобы ускорить выборку по году where extract(year from rental.rental_date) ... 
-- Также есть смысл создать индексы customer_id - rental, inventory_id - payment, film_id - film
--------------------------------------------------------------------------------------------------------------
-- Лекция по транзакциям
SELECT
    *
FROM
    job
LIMIT
    10;

INSERT INTO
    job (job_type, CHARGE_PER_HOUR)
VALUES
    ('asd', 1);

SELECT
    ctid,
    xmin,
    xmax,
    cmin,
    cmax,
    *
FROM
    job
LIMIT
    10;
